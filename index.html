<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        #connect {
            background-color: red;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        #chartContainer {
            width: 100vw;
            height: 80vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <h1>Microbit Data Graphing</h1>
    <button id="connect">Connect Device</button>
    <div id="chartContainer">
        <canvas id="dataChart" style="display: none;"></canvas>
    </div>
    
    <script>
        let port;
        let reader;
        let writer;
        let printSerialIn = false;
        let storedHeaders = [];
        let storedData = [];
        let lastRequestTime = 0;
        let chart;
        let graphTitle = "";
        let graphType = "";
        let drawnUpToRow = 0;
        const ctx = document.getElementById("dataChart").getContext("2d");
        
        function updateButtonState(isConnected) {
            const connectButton = document.getElementById("connect");
            if (isConnected) {
                connectButton.textContent = "Connected";
                connectButton.style.backgroundColor = "green";
            } else {
                connectButton.textContent = "Connect Device";
                connectButton.style.backgroundColor = "red";
            }
        }

        async function sendSerialCommand(command) {
            const currentTime = Date.now();
            if (currentTime - lastRequestTime < 500) return;
            lastRequestTime = currentTime;
            if (!port || !port.writable) return;
            try {
                if (!writer) {
                    writer = port.writable.getWriter();
                }
                await writer.write(new TextEncoder().encode(command));
            } catch (err) {
                console.error("Error sending request:", err);
            } finally {
                if (writer) {
                    writer.releaseLock();
                    writer = null;
                }
            }
        }


        async function requestGraphType(){
            await sendSerialCommand("G\n")
        };

        async function requestHeaders() {
            await sendSerialCommand("H\n");
        }

        async function requestTitle() {
            await sendSerialCommand("T\n");
        }

        function drawNewChart(type,xLables,dataSets,tmpScales={}){
            if(chart){
                chart.destroy();
            }
            chart = new Chart(ctx, {
                type: type,
                data: {
                    labels: xLables,
                    datasets: dataSets,
                },
                options: {
                    responsive: true,
                    scales : tmpScales,
                    plugins: {
                        title: {
                            display: true,
                            text: graphTitle,
                            font: {
                                size:20
                            }
                        },
                        legend: {  // Increase legend font size
                            labels: {
                                font: {
                                    size: 16 // Adjust the size as needed
                                }
                            }
                        }
                    }
                },
            });
        }

        function updateChartTitle(newTitle) {
            graphTitle = newTitle;
            if (chart) {
                chart.options.plugins.title.text = newTitle;
                chart.update();
            }
        }

        function createLineChart(){
            drawnUpToRow = storedData.length;
            let tmpScales = { x: { 
                        title: { 
                            display: true,
                            text: storedHeaders[0],
                            font: { size: 18 }
                        },
                        ticks: { maxTicksLimit: 15 }
            }};
            let tmpDatasets = storedHeaders.slice(1).map((header,index) => ({
                label:header,
                data: storedData.slice(0,drawnUpToRow).map(row=>row[index+1]),
                borderColor: `hsl(${index * 60}, 100%, 50%)`,
                fill: false
            }));
            let tmpXScales = storedData.slice(0,drawnUpToRow).map(row=>row[0]);
            drawNewChart("line",tmpXScales,tmpDatasets,tmpScales);
        }
        function createSumChart(){
            let dataToPlot = [{
                label: "Data",
                data: new Array(storedHeaders.length).fill(0),
                backgroundColor: ["red", "blue", "green", "yellow", "purple", "orange"]
            }]
            drawNewChart(graphType,storedHeaders,dataToPlot)
        }

        function updateLine(newData){
            for(row of newData){
                chart.data.labels.push(row[0]);
                chart.data.datasets.forEach((dataset, index) => {
                    dataset.data.push(row[index + 1]);
                });
            }
        }

        function updateSum(newData){
            if(chart.data.labels.length != storedHeaders.length){
                for(let i=chart.data.labels.length;i<storedHeaders.length;i++){
                    chart.data.datasets[0].data.push(0)
                }
                chart.data.labels = storedHeaders;
            }

            for(row of newData){
                for(let j=0;j< row.length;j++){
                    let elem = row[j];
                    if(! isNaN(elem)){
                        chart.data.datasets[0].data[j]+=elem;
                    }
                }
            }
        }

        function updateData(){
            if (drawnUpToRow == storedData.length){
                return;
            }
            let newDrawUpTo = storedData.length;
            let newData = storedData.slice(drawnUpToRow,newDrawUpTo);
            if(graphType == "line"){
                updateLine(newData);
            }else{
                updateSum(newData);
            }
            drawnUpToRow = newDrawUpTo;
            chart.update(); 
        }

        function createChart(){
            const chartCanvas = document.getElementById("dataChart")
            chartCanvas.style.display = "block";

            if(graphType=="bar"){
                createSumChart();
            }else if(graphType=="pie"){
                createSumChart();
            }else if(graphType=="line"){
                createLineChart();
            }

        }


        function update() {
            if(graphType == ""){
                return requestGraphType();
            }
            if(storedHeaders.length == 0){
                return requestHeaders();
            }
            if (storedData.length === 0){
                return;
            }

            if (!chart || chart.config.type !== graphType) {
                return createChart();
            }
            updateData();
        }

        setInterval(update, 1000);

        function processHeader(headerString) {
            const splitString = headerString.split(",");
            if (splitString.length <= storedHeaders.length) return;
            
            for (let i = 0; i < storedHeaders.length; i++) {
                if (splitString[i] !== storedHeaders[i]) {
                    console.error("Malformed header string.");
                    return;
                }
            }
            
            let headersUpdated = false;
            splitString.forEach(name => {
                if (!storedHeaders.includes(name)) {
                    storedHeaders.push(name);
                    headersUpdated = true;
                }
            });
            if(headersUpdated){
                storedData.forEach(row=>{
                    while(row.length < storedHeaders.length){
                        row.push(NaN);
                    }
                })
            }
        }

        function processData(dataArray) {
            if (dataArray.length !== storedHeaders.length) {
                console.error("Data mismatch with headers.");
                requestHeaders();
                return;
            }
            storedData.push(dataArray);
        }

        function onReceive(data) {
            if (!data) return;
            if(printSerialIn){
                console.log(data);
            }
            if (data.startsWith("H:") && data.endsWith(":H")) {
                processHeader(data.slice(2, -2));
            }else if (data.startsWith("T:") && data.endsWith(":T")) {
                updateChartTitle(data.slice(2,-2));
            } else if (data.startsWith("G:") && data.endsWith(":G")) {
                graphType = data.slice(2,-2);
            }else{
                let newRow = [];
                let valid = true;
                for(const elem of data.split(",")){
                    let parsed = parseFloat(elem);
                    if (isNaN(parsed) && elem!==""){
                        console.log("recieved invalid row");
                        console.log(data)
                        return;
                    }
                    newRow.push(parsed);
                }
                processData(newRow);
            }
        }

        async function serialReader() {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                updateButtonState(true);
                reader = port.readable.getReader();
                let buffer = "";
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const str = new TextDecoder().decode(value);
                    buffer += str;
                    let lines = buffer.split("\n");
                    buffer = lines.pop();
                    lines.forEach(line => onReceive(line.trim()));
                }
                reader.releaseLock();
            } catch (err) {
                console.error("Error:", err);
                updateButtonState(false);
            }
        }

        document.getElementById("connect").addEventListener("click", serialReader);
    </script>
</body>
</html>
